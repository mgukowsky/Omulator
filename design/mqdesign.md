- What differentiates MQ from, say, Go channels is the ability to batch messages into a buffer and send them all at once. This sending needs to be lightweight, otherwise we gain no advantage from using the framework; i.e. we could copy the entire buffer of messages to prevent lifetime issues arising from copying MessageBuffers with the same underlying storage, however that would be an O(n) operation. Moving a pointer, on the other hand, gives us an O(1) send operation at the cost of more complex lifetime management. Since lifetime management is thus a necessity, I will stick with the factory implementation, since that A) removes the onus of lifetime management away from the client (e.g. no manual calls to std::move), B) allows us to hide implementation details from the client (e.g. pass the MQ around by value but have it store and internal ptr), and C) allows MessageBuffers to be copyable and moveable. The caveat is that if a client does something funky with an MQ (e.g. uses it after a call to send), that's on them, and also that anyone who needs an MQ instance will first need to retrieve a reference to the factory via DI. Another nice-to-have for the design would be to make MessageQueueFactory something like PooledFactory<T>, since the internals are certainly generic enough to support this.

N.B. that the primary use case for batched messages is to allow for features like having audio and graphics events decoupled across threads (or more generally, the ability utilize the Command pattern in an asynchronous and sequentially consistent manner).
